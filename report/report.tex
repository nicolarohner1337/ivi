\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[letterpaper,top=1.5cm,bottom=1.5cm,left=2cm,right=2cm,marginparwidth=1.75cm]{geometry}
\usepackage[english]{babel}
\usepackage[skip=2pt]{caption}
\usepackage{graphicx}
\usepackage[colorlinks=false, allcolors=black, hidelinks=true]{hyperref}
\usepackage{biblatex}
\usepackage{makecell}
\addbibresource{IVI.bib}

\title{Interactive Visualizations (IVI) Bericht}
\author{Nicola Rohner}
\date{SE FE 2023}

\begin{document}

\maketitle

\begin{center}
\textbf{Repository:} \url{https://github.com/nicolarohner1337/ivi}
\end{center}

\begin{abstract}
In diesem Bericht werden die Lernergebnisse des Moduls IVI zusammengefasst.\\
Für alle ausser LE1 wurden folgende Daten verwendet: \newline
GroupLens Research hat Bewertungsdatensätze von der MovieLens-Website \url{https://movielens.org} gesammelt und zur Verfügung gestellt.
Die Datensätze wurden über verschiedene Zeiträume hinweg gesammelt, abhängig von der Größe des Satzes. Das ZIP findet man unter folgendem Link: \url{https://files.grouplens.org/datasets/movielens/ml-latest.zip}
Die Daten umfassen 27.000.000 Bewertungen und 1.100.000 Tag-Anwendungen für 58.000 Filme von 280.000 Nutzern. Beinhaltet Tag-Genom-Daten mit 14 Millionen Relevanz-Scores für 1.100 Tags.\\
\noindent\\
Die Visualisierungen in diesem Bericht wurden alle selbst erstellt. 
Der Datensatz wurde bereits für die Challenge CDS1 genutzt und für die Erarbeitung von GDV.
\end{abstract}

\tableofcontents

\newpage

\section{LE1: Performance}
In Zeiten von Big Data ist es wichtig, dass Visualisierungen schnell und performant sind. In diesem LE wird untersucht, wie sich die Performance von Visualisierungen auf verschiedene Arten beeinflussen lässt.


\subsection{WebGL}
WebGL ist eine leistungsstarke Technologie, die Berechnungen beschleunigt. Allerdings gibt es einige Einschränkungen.
WebGL benötigt eine GPU (Grafikkarte), die nicht immer in allen Browsern verfügbar ist.
Die CPU verarbeitet alle Hauptfunktionen des Computers, während die GPU viele kleinere Aufgaben gleichzeitig ausführt.\cite{noauthor_cpu_nodate}

%make 5x2 table
%how can i align the text in the cells?
\begin{table}[!h]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{CPU} & \textbf{GPU} \\
\hline
\makecell[l]{Generalistische Komponente - Verarbeitet die \\ wichtigsten Verarbeitungsfunktionen eines Computers}& \makecell[l]{Spezialisierte Komponente - Verarbeitet \\Grafik- und Video-Rendering} \\
\hline
Kernanzahl- 2-64 (die meisten CPUs)&Kernanzahl- Tausende \\
\hline
Führt Prozesse seriell aus & Führt Prozesse parallel aus\\
\hline
\makecell[l]{Besser bei der Verarbeitung\\ einer großen Aufgabe zur gleichen Zeit} & \makecell[l]{Besser bei der Verarbeitung \\mehrerer kleinerer Aufgaben zur gleichen Zeit} \\
\hline
\end{tabular}
\caption{\label{tab: LE1 CPU vs GPU}CPU vs GPU}
\end{table}
    
\noindent
Mit WebGL gerenderte Daten werden als Pixelraster gezeichnet, was in einigen Fällen zu verpixelten oder unscharfen Bildern führen kann.
Browser begrenzen die Anzahl der WebGL Kontexte, auf die ein bestimmtes Webdokument zugreifen kann, was die Darstellung von WebGL-Visualisierungen einschränken kann.
Browser setzen Grenzen für die Höhe und Breite von Visualisierungen, die WebGL verwenden, was bei extrem großen Plots zu Problemen führen kann.\cite{plotly_webgl_nodate}
%hard break
\newline
\newline
Um die Performance Unterschiede zu untersuchen habe ich eine Visualisierung erstellt, welche 100000 zufällige Punkte in einem 2D Koordinatensystem darstellt.
Einmal wurde die Visualisierung mit dem Modus SVG und einmal mit WebGL gerendert. Was bereits qualitativ auffällt ist, dass die WebGL Visualisierung deutlich schneller angezeigt wird im Chrome Browser.

%enter image here
\begin{figure}[!h]
\centering
\includegraphics[width=0.2\textwidth]{img/random_dots.png}


\caption{\label{fig: LE1 Random Dots plot}Random dots}
\end{figure}

\noindent
Die Chrome Entwickler Tools verfügen über ein Performance Profiler Tool, welches die Performance einer Webseite analysieren kann. Es unterteilt die Laufzeitleistung in das RAIL-Modell\cite{noauthor_measure_nodate}: Response, Animation, Idle und Load.
Im Kontext zur Visualisierung betrachte man die Scripting, Rendering und Painting Kategorien.\cite{kayce_basques_analyze_nodate}

%enter table here
\begin{table}[!h]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Kategorie} & \textbf{SVG} & \textbf{WebGL} & \textbf{\%$\Delta$} \\
\hline
Scripting & 3778ms & 651ms & -580\% \\
\hline
Rendering & 2026ms & 14ms & -1447\% \\
\hline
Painting & 197ms & 2ms & -985\% \\
\hline
\end{tabular}
\caption{\label{tab: LE1 Performance}Performance Unterschiede}
\end{table}

\noindent
Zu beobachten ist ein signifikanter Unterschied in den Rendering und Painting Zeiten der beiden Visualisietungen. Auch die subjektive Wahrnehmung der Performance ist deutlich besser bei der WebGL Visualisierung.
Auch die Tradeoffs zwischen Performance und Qualität sind deutlich zu erkennen. Die SVG Visualisierung ist deutlich schärfer und die Punkte sind deutlich besser zu erkennen.
\begin{figure}[!h]
\centering
\includegraphics[width=0.2\textwidth]{img/svg_quality.png}
\includegraphics[width=0.2\textwidth]{img/webgl_quality.png}
\setlength{\belowcaptionskip}{-10pt}
\caption{\label{fig: LE1 Qualität Unterschiede} Qualität Unterschiede links SVG, rechts WebGL}
\end{figure}
\newpage

\subsection{Tiling}

Tiling wurde von Google Maps erfunden, um die Rechenleistung zu optimieren. Die Karte wird in kleinere Teile unterteilt und nur die benötigten Daten für den jeweiligen Zoomlevel werden angezeigt.
Diese kleineren Kacheln komprimieren nicht nur die Daten, sondern geben das Rendering an den Webbrowser ab, wodurch die für die Karte erforderliche Nutzlast weiter reduziert wird.\cite{noauthor_map_nodate}
Datashader ist ein Grafik-Pipeline-System zur schnellen und flexiblen Erstellung aussagekräftiger Darstellungen grosser Datensätze. Datashader unterteilt die Erstellung von Bildern in eine Reihe expliziter Schritte, die es ermöglichen, Berechnungen an Zwischendarstellungen vorzunehmen.\cite{wong_abstract_2013}
\\
\\
Wir visualisieren hier die räumliche Verteilung der Taxifahrten in New York City. 
Die Daten werden von Plotly zu Verfügung gestellt und sind unter folgendem Link zu finden: \url{https://raw.githubusercontent.com/plotly/datasets/master/uber-rides-data1.csv}

\begin{table}[!h]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Date/Time} & \textbf{The date and time of the Uber pickup} \\
\hline
\textbf{Lat} & \textbf{The latitude of the Uber pickup} \\
\hline
\textbf{Lon} & \textbf{The longitude of the Uber pickup} \\
\hline
\end{tabular}
\caption{\label{tab: LE1 Newyork Taxi Data} Newyork Uber Data}
\end{table}



%enter image here
\begin{figure}[!h]
\centering
\includegraphics[width=0.4\textwidth]{img/newyork_plotly.png}
\includegraphics[height=0.18\textwidth]{img/newyork_datashader.png}
\caption{\label{fig: LE1 Plotly vs Datashader} Taxifahrten in Newyork (Plotly links, Datashader Tiles rechts)}
\end{figure}
\noindent
Zu beobachten ist das die unprozessierten Daten mit Plotly zwar schöner dargestellt werden. Aber viel länger brauchen um angezeigt zu werden. Die Datashader Visualisierung ist deutlich schneller und die Daten werden deutlich besser dargestellt.
Diese Beobachtungen wiederspiegeln sich auch in den Performance Daten. Zwar wird nur die Scripting Zeit signifikant verkürzt.


%enter table here
\begin{table}[!h]
    \centering
    \begin{tabular}{|l|l|l|l|}
    \hline
    \textbf{Kategorie} & \textbf{Plotly} & \textbf{Datashader Tile} & \textbf{\%$\Delta$} \\
    \hline
    Scripting & 1241ms & 492ms & -39\% \\
    \hline
    Rendering & 6ms & 6ms & $\pm$0\% \\
    \hline
    Painting & 12ms & 12ms & $\pm$0\% \\
    \hline
    \end{tabular}
    \caption{\label{tab: LE1 Performance}Performance Unterschiede}
\end{table}
\noindent
Spannender bei diesem Fall sind die Unteschiede des genutzen Speichers. Wenn wir den JavaScript Heap betrachten sehen wir einen signifikanten Unterschied.\cite{noauthor_memory_2023}
Plotly braucht fast 130MB um die Daten zu visualisieren, der Datashader Tile braucht nur 23MB.

%enter image here
\begin{figure}[!h]
\centering
\includegraphics[width=0.2\textwidth]{img/js_heap_plotly.png}
\includegraphics[height=0.158\textwidth]{img/js_heap_datashader.png}
\caption{\label{fig: LE1 Datashader Memory} Memory Heap Plotly vs. Datashader Tile}
\end{figure}
\noindent
Einen ähnlichen Ansatz verfolgen auch Framworks wie Deck.gl. Diese Frameworks sind jedoch auf WebGL basiert und können somit nur auf Browsern mit WebGL Unterstützung verwendet werden.
Sie prozessieren für verschiedene Ansichte voragregierte Tiles und können so sehr schnell und performant visualisieren.\cite{deckgl_home_nodate}

\newpage

\section{LE2: Grundsätze für die Gestaltung von Dashboards}

Ein wichtiger Aspekt bei der Entwicklung von Dashboards ist das Konzept. Dabei hat der Benutzer Zugriff auf verschiedene Steuerelemente und mehrere verknüpfte Visualisierungen. Diese Designprinzipien sind entscheidend für die Entwicklung eines erfolgreichen Dashboards.

\subsection{Schneiderman’s Mantra}
Schneiderman's Mantra ist ein Organisationsprinzip für die Erstellung von Visualisierungssystemen. Es lautet wie folgt:\\ \\
\noindent
\textbf{Overview first}: Im Überblicksschritt wird der gesamte Datensatz in einer geeigneten Anzeigemethode dargestellt. Dies bietet einen Überblick auf hoher Ebene und gibt Kontext für die nächsten Schritte in der Visualisierung.\\ \\
\textbf{Zoom and filter}: Zoomen auf einen Abschnitt des Datensatzes ermöglicht das Entfernen von überflüssigen Daten anhand der angezeigten Koordinaten. So erhalten die relevanten Daten mehr Auflösung und Detail. Das Filtern entfernt überflüssige Daten basierend auf gewünschten Attributen, vereinfacht die Anzeige Ihrer Daten und schafft mehr Platz für Details.\\ \\
\textbf{Details on demand}: Details auf Abruf geben dem Benutzer Kontrolle über die Daten und ermöglichen es, ohne Überladen des Bildschirms weiter zu erkunden. Das Tooltip ist die häufigste Implementierung. Eine andere Möglichkeit besteht darin, ein Feld auszuwählen und die Daten hervorzuheben.\cite{hampdatavisualization_schneidermans_2016}
\\
Eine mögliche Umsetzung mit diesem Prinzip könnte wie folgt aussehen. Im ersten Schritt wird eine Übersicht über die Anzahl Filme pro Genre gegeben.


\begin{figure}[!h]
\centering
\includegraphics[width=0.4\textwidth]{img/movies_genre.png}
\caption{\label{fig: LE2 Schneiderman Overview} Genre Übersicht}
\end{figure}


Wenn der Benutzer nun auf ein Genre klickt oder auf ein Genre zoomt wird die Anzahl Filme pro Jahr angezeigt.\\

\begin{figure}[!h]
\centering
\includegraphics[width=0.4\textwidth]{img/movies-scifi.png}
\caption{\label{fig: LE2 Schneiderman Zoom} Filtering/Zooming: Anzahl Filme pro Jahr}
\end{figure}


Mit einem Tooltip kann der Benutzer nun die Details zum einzelnen Film einsehen.

\begin{figure}[!h]
    \centering
    \includegraphics[width=0.2\textwidth]{img/tooltip.png}
    \caption{\label{fig: LE2 Schneiderman Zoom} Tooltip: Details on demand}
    \end{figure}
Diese Interaktionen können mit Hilfe Plotly.js Chart Events realisiert werden. Wenn ein solches Event getriggert wird kann die Funktion \texttt{Plotly.restyle} aufgerufen werden. Diese Funktion ermöglicht es die Daten eines Charts zu ändern.\\


\newpage
\subsection{Verknüpfte Ansichten}
Das Paradigma der verknüpften Ansichten ist eine Methode, die mehrere einfache Ansichten von Daten verwendet. Wenn Sie mit einer Ansicht interagieren, ändert sich die Anzeige der Daten in allen verknüpften Ansichten. Ein einfaches Beispiel wäre, dass die Auswahl eines Datums in einer Ansicht die Daten in allen anderen Ansichten auch ändert.
Kurz gesagt wenn sich eine Ansicht ändert, ändern sich alle anderen Ansichten auch.\cite{wills_linked_2008} \\
%TODO: add image
\subsection{Brushing}
Brushing ist eine Methode, die es ermöglicht, Daten in einer Ansicht zu selektieren und diese dann in anderen Ansichten zu verwenden. Ein Beispiel wäre, dass Sie eine Ansicht mit einem Scatterplot haben, in der Sie einen Bereich selektieren. Diese Selektion wird dann in einer anderen Ansicht mit einem Histogramm verwendet.\cite{becker_brushing_1987} \\

\begin{figure}[!h]
\centering
\includegraphics[width=0.4\textwidth]{img/brushing.png}
\caption{\label{fig: LE2 Brushing} Brushing}
\end{figure}

\subsection{Filtering}
Dynamische Abfragen sind eine direkte Möglichkeit, um Daten mit Schiebereglern, Knöpfen und Kategorien zu filtern. 
Sie zeigen globale Eigenschaften auf und helfen bei der Beantwortung spezifischer Fragen ohne Fehlermeldungen. 
Fortgeschrittene Filter erlauben in der Regel OR-Kombinationen innerhalb eines Attributs oder AND-Kombinationen über Attribute hinweg. 
So können komplexere Abfragen gestellt werden.\cite{shneiderman_eyes_1996} \\

\subsection{Implementation mit Dash}

Mit Dash habe ich ein interaktives Dashboard entwickelt, welches die oben genannten Prinzipien implementiert. Das Dashboard ist in Python geschrieben und basiert auf dem Dash Framework. Dash ist ein Framework, welches auf Plotly.js basiert und es ermöglicht interaktive Webanwendungen zu entwickeln.\cite{noauthor_dash_nodate} \\

%add image
\begin{figure}[!h]
\centering
\includegraphics[width=0.4\textwidth]{img/dashboard_plotly.png}
\caption{\label{fig: LE2 Dashboard} Dashboard}
\end{figure}

Mit einem Mulit-Select können die Genres ausgewählt werden. Es wird eine zusätzliche verknüopfte Ansicht angezeigt, welche die Anzahl Filme pro Jahr anzeigt.\\
Zudem kann mit einem Datepicker ein Zeitraum ausgewählt werden. Dieser wird dann in allen anderen Ansichten verwendet.\\

\newpage


\printbibliography


\end{document}